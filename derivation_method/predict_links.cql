WITH $ASSIGN_CLASSES as ASSIGN_CLASSES, $`CLASSES AFTER RUNSCRIPT` as `CLASSES AFTER RUNSCRIPT`, $`NEW RUNSCRIPT CLASSES` as `NEW RUNSCRIPT CLASSES`, $`PREDICTED CLASSES` as `PREDICTED CLASSES`
MATCH (C_PRIMARY:Class) WHERE C_PRIMARY.short_label in `PREDICTED CLASSES`
MATCH (c_schema:Class)<-[x:TO|FROM]-(rs)-[y:FROM|TO]->(C_PRIMARY) where C_PRIMARY.derived='true' and not exists(c_schema.is_stat) and not((c_schema)<-[:HAS_DATASET]-() and not substring(c_schema.short_label,0,4)='SUPP') and not 'ObservationClass' in labels(c_schema)
with C_PRIMARY, ASSIGN_CLASSES, `CLASSES AFTER RUNSCRIPT`, `NEW RUNSCRIPT CLASSES`, `PREDICTED CLASSES`, apoc.coll.insert(apoc.coll.sort(collect(distinct(c_schema.short_label))),0,C_PRIMARY.short_label) as POSSIBLE_SCHEMA_LINKS
WITH C_PRIMARY, ASSIGN_CLASSES, `CLASSES AFTER RUNSCRIPT`, `NEW RUNSCRIPT CLASSES`, `PREDICTED CLASSES`, POSSIBLE_SCHEMA_LINKS

//REMOVING DUPLICATE CLASSES FROM CLASSES AFTER RUNSCRIPT & COMBINE ALL CLASSES RELATED TO LINKs (CL2)
WITH C_PRIMARY, ASSIGN_CLASSES, `NEW RUNSCRIPT CLASSES`, `PREDICTED CLASSES`, POSSIBLE_SCHEMA_LINKS, apoc.coll.dropDuplicateNeighbors(apoc.coll.sort(apoc.coll.flatten(collect(distinct `CLASSES AFTER RUNSCRIPT`)))) as `CLASSES AFTER RUNSCRIPT`

//CREATE THE MAP THAT SHOWS DIRECTION OF THE RELATIONSHIP (CLASS<-) OR (CLASS->) and  PREDICTED LINKS:VALID CLASSES FROM RUNSCRIPT/ASSIGN CLASS (CLASSES ALSO IN SCHEMA)
WITH C_PRIMARY, [a in apoc.coll.union(`CLASSES AFTER RUNSCRIPT`,ASSIGN_CLASSES) WHERE a in POSSIBLE_SCHEMA_LINKS] as `PREDICTED LINKS:VALID CLASSES FROM RUNSCRIPT/ASSIGN CLASS (CLASSES ALSO IN SCHEMA)`,`CLASSES AFTER RUNSCRIPT`, ASSIGN_CLASSES

//PREPARING FOR MAP BUT FOR THE PREDICTED CLASSES
MATCH (pos_c:Class)<-[l:TO|FROM]-(rx)-[:FROM|TO]->(C_PRIMARY) where pos_c.short_label in `PREDICTED LINKS:VALID CLASSES FROM RUNSCRIPT/ASSIGN CLASS (CLASSES ALSO IN SCHEMA)`
WITH C_PRIMARY, apoc.coll.sort(collect(pos_c.short_label)) as C_PRIMARY_pred, l, apoc.map.fromPairs(collect([pos_c.short_label, pos_c])) as CLS_NODE_MAP
WITH C_PRIMARY, CLS_NODE_MAP, apoc.map.fromValues([type(l), C_PRIMARY_pred]) as map_pred

//PREPARE THE OUTPUT COLUMNS - REMOVE ANY 'DEF' CLASSES AND THE CASES WHERE ACTUAL IS EQUAL TO  PREDICTED (WE ONLY WANT TO SEE THE CASES WHERE THEY DON'T MATCH)
WITH C_PRIMARY, CLS_NODE_MAP,
apoc.coll.dropDuplicateNeighbors(apoc.coll.sort(apoc.coll.flatten(collect(map_pred['FROM'])))) as `PREDICTED FROM_LINK(CLASS<-)`, 
apoc.coll.dropDuplicateNeighbors(apoc.coll.sort(apoc.coll.flatten(collect(map_pred['TO'])))) as `PREDICTED TO_LINK(CLASS->)`
//TRY TO ASSESS ISSUE + SORTING OF LISTS
WITH C_PRIMARY, CLS_NODE_MAP,
// convert short_labels to class nodes
[CLS in `PREDICTED FROM_LINK(CLASS<-)` | CLS_NODE_MAP[CLS]] as PREDICTED_FROM_CLASSES,
[CLS in `PREDICTED TO_LINK(CLASS->)` | CLS_NODE_MAP[CLS]] as PREDICTED_TO_CLASSES
RETURN collect(apoc.map.fromPairs([["C_PRIMARY", C_PRIMARY], ["PREDICTED_FROM_CLASSES", PREDICTED_FROM_CLASSES], ["PREDICTED_TO_CLASSES", PREDICTED_TO_CLASSES]])) as PREDICTED_LINKS
// RETURN METHOD_ID, C_PRIMARY.short_label as CLS, [x IN PREDICTED_FROM_CLASSES | x.short_label] as FROM_CLASSES, [x IN PREDICTED_TO_CLASSES | x.short_label] as TO_CLASSES order by METHOD_ID, CLS